local button = require "utils.button"
local monarch = require "monarch.monarch"
local storage = require "pokedex.storage"
local _pokemon = require "pokedex.pokemon"
local gesture = require "utils.gesture"

local function join_table(title, T, sep)
	if T then
		return title .. table.concat(T, sep)
	end
	return ""
end

local function to_mod(v)
	local value = math.floor((v - 10) / 2)
	if value >= 0 then
		value = "+" .. value
	end
	return value
end

local function show_description(desc)
	monarch.show("info", {}, {txt=desc})
end

local function setup_moves(self, nodes, pokemon)
	local index = 0
	local function _get_node(sub)
		local move_name = "pokemon/move_" .. index
		local n = nodes[move_name .. sub]
		return n
	end

	for name, data in pairs(pokemon.moves) do
		index = index + 1
		local pp_node = _get_node("/pp")
		button.register(_get_node("/btn_decease_pp"), function()
			_pokemon.decrease_move_pp(pokemon, name)
			gui.set_text(pp_node, "PP: " .. pokemon.moves[name].current_pp)
		end)

		button.register(_get_node("/btn_reset_pp"), function()
			_pokemon.reset_move_pp(pokemon, name)
			gui.set_text(pp_node, "PP: " .. pokemon.moves[name].current_pp)
		end)
		
		button.register(_get_node("/name"), function()
			show_description(data.description)
		end)
		
		gui.set_text(_get_node("/action"), data.time)
		gui.set_text(_get_node("/duration"), data.duration)
		gui.set_text(pp_node, "PP: " .. data.current_pp)

		if data.damage then
			gui.set_text(_get_node("/bonus"), "AB: " .. data.AB)
			gui.set_text(_get_node("/damage"), data.damage)
			if damage.save then
				if not data.AB then
					gui.set_enabled(_get_node("/bonus"), false)
				end
			end
			gui.set_text(_get_node("/damage"), "Save DC: " .. data.save_dc)
		end

		gui.set_text(_get_node("/name"), name)
		if data.STAB_MOVE then
			gui.set_color(_get_node("/name"), vmath.vector4(1, 1, .5, 1))
		end
		gui.set_text(_get_node("/range"), data.range)
	end
	for i=index+1, 5 do
		local n = nodes["pokemon/move_" .. i .. "/root"]
		gui.delete_node(n)
	end
end

local function setup_abilities(self, nodes, pokemon)
	local index = 0
	local template = nodes["pokemon/ability/root"]
	local function _get_node(sub)
		local name = "pokemon/ability_" .. index
		local n = nodes[name .. sub]
		return n
	end
	local p = vmath.vector3()
	for name, desc in pairs(pokemon.abilities) do
		local root_node = gui.clone(nodes["pokemon/ability/root"])
		local name_node = gui.clone(nodes["pokemon/ability/name"])
		local desc_node = gui.clone(nodes["pokemon/ability/description"])

		gui.set_text(name_node, name)
		gui.set_text(desc_node, desc)
		
		gui.set_parent(name_node, root_node)
		gui.set_parent(desc_node, root_node)
		gui.set_position(root_node, p)
		p.y = p.y - (gui.get_text_metrics_from_node(desc_node).height + gui.get_text_metrics_from_node(name_node).height + 50)
		index = index + 1
	end
	gui.delete_node(template)
end

local function setup_info(self, nodes, pokemon)
	local abilities_string = 
	"STR: " .. to_mod(pokemon.attributes.STR) .. "  INT: " .. to_mod(pokemon.attributes.INT) .. "\n" .. 
	"DEX: " .. to_mod(pokemon.attributes.DEX) .. "  WIS: " .. to_mod(pokemon.attributes.WIS) .. "\n" .. 
	"CON: " .. to_mod(pokemon.attributes.CON) .. "  CHA: " .. to_mod(pokemon.attributes.CHA) .. "\n"
	gui.set_text(nodes["pokemon/attributes"], abilities_string)

	local saving_throw_string =
	"STR: " .. to_mod(pokemon.saving_throw.STR) .. "  INT: " .. to_mod(pokemon.saving_throw.INT) .. "\n" .. 
	"DEX: " .. to_mod(pokemon.saving_throw.DEX) .. "  WIS: " .. to_mod(pokemon.saving_throw.WIS) .. "\n" .. 
	"CON: " .. to_mod(pokemon.saving_throw.CON) .. "  CHA: " .. to_mod(pokemon.saving_throw.CHA) .. "\n"

	gui.set_text(nodes["pokemon/savingthrows"], saving_throw_string)
	gui.set_text(nodes["pokemon/stab"], "STAB: " .. pokemon.STAB)
	gui.set_text(nodes["pokemon/prof"], "Prof: " .. pokemon.proficiency)
	gui.set_text(nodes["pokemon/skills"], table.concat(pokemon.skills, ", "))
end

local function update_hp(self, nodes, pokemon)
	gui.set_text(nodes["pokemon/hp_current"], "HP: " .. pokemon.current_hp)
	local p = gui.get_position(nodes["pokemon/hp_current"])
	p.x = p.x + (gui.get_text_metrics_from_node(nodes["pokemon/hp_current"]).width * 2)

	gui.set_text(nodes["pokemon/hp"], "/" .. pokemon.HP)
	gui.set_position(nodes["pokemon/hp"], p)
end

local function setup_page(self, nodes, pokemon)
	button.register(nodes["pokemon/hp_current"], function()
		_pokemon.set_current_hp(pokemon, pokemon.current_hp-1)
		update_hp(self, nodes, pokemon)
	end)
	button.register(nodes["pokemon/hp"], function()
		_pokemon.set_current_hp(pokemon, pokemon.current_hp+1)
		update_hp(self, nodes, pokemon)
	end)
	
	gui.set_text(nodes["pokemon/species"], pokemon.species)
	gui.set_text(nodes["pokemon/level"], "lvl: " .. pokemon.level)
	gui.set_text(nodes["pokemon/nature"], pokemon.nature)
	gui.set_text(nodes["pokemon/ac"], "AC: " .. pokemon.attributes.AC)

	update_hp(self, nodes, pokemon)
	local pos = vmath.vector3()
	local vul = nodes["pokemon/vulnerabilities"]
	local imm = nodes["pokemon/immunities"]
	local res = nodes["pokemon/resistances"]
	gui.set_text(vul, join_table("Vulnerabilities: ", pokemon.vulnerabilities, ", "))
	
	pos.y = pos.y - gui.get_text_metrics_from_node(vul).height
	gui.set_text(res, join_table("Resistances: ", pokemon.resistances, ", "))
	gui.set_position(res, pos)
	
	pos.y = pos.y - gui.get_text_metrics_from_node(res).height
	gui.set_text(imm, join_table("Immunities: ", pokemon.immunities, ", "))
	gui.set_position(imm, pos)

	setup_moves(self, nodes, pokemon)
	setup_abilities(self, nodes, pokemon)
	setup_info(self, nodes, pokemon)
end

local function activate_tab(self, page, tab_number)
	for i=1, 3 do
		if tab_number == i then
			gui.set_enabled(page["pokemon/tab_bg_" .. i], true)
		else
			gui.set_enabled(page["pokemon/tab_bg_" .. i], false)
		end
	end
end

local function add_pokemon_page(self, pokemon_id, index)
	local page = gui.clone_tree(self.pokemon_page)
	local p = vmath.vector3()
	p.x = (index-1) * 720
	gui.set_position(page["pokemon/root"], p)
	button.register(page["pokemon/tab_1"], function()
		activate_tab(self, page, 1)
	end)
	button.register(page["pokemon/tab_2"], function()
		activate_tab(self, page, 2)
	end)
	button.register(page["pokemon/tab_3"], function()
		activate_tab(self, page, 3)
	end)
	return page
end

function init(self)
	button.acquire()
	self.pokemon_page = gui.get_node("pokemon/root")
	self.pokemons_list = {}
	self.pokemon_index = 0
	gui.set_text(gui.get_node("pokemon/move_1/name"), "NAME")
	
	button.register("btn_back", function()
		monarch.show("splash")
	end)
	
	button.register("btn_edit", function()
		monarch.show("edit", {}, {id=self.pokemons_list[self.pokemon_index+1].pokemon_id})
	end)
	
	for index, pokemon_id in pairs(storage.list_of_ids_in_inventory()) do
		local page = add_pokemon_page(self, pokemon_id, index)
		local pokemon_data = storage.get(pokemon_id)

		table.insert(self.pokemons_list, {pokemon_id=pokemon_id, nodes=page, pokemon=pokemon_data})
		setup_page(self, page, pokemon_data)
	end
	if next(self.pokemons_list) ~= nil then
		for _, poke in pairs(self.pokemons_list) do
			activate_tab(self, poke.nodes, 1)
		end
	end

	gui.delete_node(self.pokemon_page)
end

function final(self)
	button.unregister()
end

function update(self, dt)
	-- Add update code here
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

local function change_pokemon(self)
	local r = gui.get_node("root")
	local p = vmath.vector3()
	p.x = self.pokemon_index * -720
	gui.animate(r, "position", p, gui.EASING_INSINE, 0.2)
end

function on_input(self, action_id, action)
	button.on_input(action_id, action)
	local g = gesture.on_input(self, action_id, action)
	if g then
		if g.swipe_right then
			self.pokemon_index =  math.max(self.pokemon_index - 1, 0)
			change_pokemon(self)
		elseif g.swipe_left then
			self.pokemon_index = math.min(self.pokemon_index + 1, #storage.list_of_ids_in_inventory()-1)
			change_pokemon(self)
		end
	end
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
