local button = require "utils.button"
local monarch = require "monarch.monarch"
local storage = require "pokedex.storage"
local _pokemon = require "pokedex.pokemon"
local pokedex = require "pokedex.pokedex"
local inventory = require "screens.storage.inventory"
local gro = require "utils.gui_render_order"
local url = require "utils.url"

local inventory_buttons = {}

local function update_storage()
	msg.post(url.STORAGE, "inventory_updated")
	msg.post(url.STORAGE, "storage_updated")
end


local function set_pokemon_sprite(sprite, pokemon)
	local pokemon_sprite, texture = _pokemon.get_sprite(pokemon)
	gui.set_texture(sprite, texture)
	gui.play_flipbook(sprite, pokemon_sprite)
end


local function inventory_button(node, id, swap)
	return button.register(node, function()
		if not id or not swap then
			return
		end
		storage.move_to_storage(id)
		storage.move_to_inventory(swap)
		update_storage()
		monarch.back()
	end)
end


local function setup_inventory(self)
	local inventory = storage.list_of_ids_in_inventory()

	for i=1, 6 do
		local pokemon = storage.get_copy(inventory[i])
		local sprite = gui.get_node("swap_pokemon_" .. i .. "/pokemon_sprite")
		if pokemon then
			gui.set_enabled(sprite, true)
			set_pokemon_sprite(sprite, pokemon)
			table.insert(inventory_buttons, inventory_button(sprite, inventory[i], self.pokemon_id))
		else
			gui.set_enabled(sprite, false)
		end
	end
end


local function setup_info(self)
	local pokemon = storage.get_copy(self.pokemon_id)
	set_pokemon_sprite(gui.get_node("pokemon_sprite"), pokemon)
	
	gui.set_text(gui.get_node("txt_index"), string.format("#%03d", _pokemon.get_index_number(pokemon)))
	gui.set_text(gui.get_node("txt_lvl"), _pokemon.get_current_level(pokemon))
	gui.set_text(gui.get_node("txt_ac"), _pokemon.get_AC(pokemon))
	gui.set_text(gui.get_node("txt_hp"), "HP: " .. _pokemon.get_current_hp(pokemon) .. "/" .. _pokemon.get_max_hp(pokemon))

	local index = 1
	local moves_string = ""
	local pp_string = ""
	for move, data in pairs(_pokemon.get_moves(pokemon)) do
		moves_string = moves_string .. move .. "\n"
		pp_string = pp_string .. _pokemon.get_move_pp(pokemon, move) .. "/" .. pokedex.get_move_pp(move) .. "\n"
	end
	
	gui.set_text(gui.get_node("txt_moves"), moves_string)
	gui.set_text(gui.get_node("txt_pp"), pp_string)
	
	--gui.set_text(gui.get_node("txt_speed"), _pokemon.get_speed(pokemon))
end


function init(self)
	button.acquire()
	gui.set_render_order(gro.POPUP)
	local d = monarch.data("move_pokemon")
	local to = d.to
	self.pokemon_id = d.id

	setup_info(self)
	
	gui.set_text(gui.get_node("txt_move"), "Move to " .. to)
	local swap = gui.get_node("swap")
	local move = gui.get_node("move")

	if to == "inventory" then
		if storage.free_space_in_inventory() then
			gui.set_enabled(swap, false)
			gui.set_enabled(move, true)
		else
			gui.set_enabled(swap, true)
			gui.set_enabled(move, false)
		end
		setup_inventory(self)
	else
		gui.set_enabled(swap, false)
		gui.set_enabled(move, true)
	end

	button.register("btn_move", function()
		if to == "inventory" then
			storage.move_to_inventory(self.pokemon_id)
		elseif to == "storage" then
			storage.move_to_storage(self.pokemon_id)
		end
		update_storage()
		monarch.back()
	end)

	button.register("btn_close", function()
		monarch.back()
	end)

	button.register("btn_cancel", function()
		monarch.back()
	end)

	button.register("btn_release", function()
		storage.release_pokemon(self.pokemon_id)
		update_storage()
		monarch.back()
	end)
end


function final(self)
	button.unregister()
end


function on_input(self, action_id, action)
	button.on_input(action_id, action)
	return true
end
